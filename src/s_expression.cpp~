#include "s_expression.h"

using namespace lispic;

Symbol
funcall(List* list)
{
     Function& f = evalfunc( list->car() ); // evalfunc(Symbol&) -> Function*
     List& args = evallist( list->cdr() ); // evallist(List*) -> List*
     
     if (f->signature.length() != args->length()) {
	  throw signature_error();
     }
     
     Environment fenv;
     for (List::iterator p = args.begin(), Function::signature::iterator fp = f.signature.begin();
	  p != args.end(), fp != f.signature.end();
	  p++, fp++)
     {
	  fenv[fp.name()] = p.value();
     }
     

     ENVS.push_back(fenv);
     Symbol result = f.call();
     ENVS.pop_back();
     return result;
}
